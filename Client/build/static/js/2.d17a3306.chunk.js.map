{"version":3,"sources":["../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@progress/kendo-data-query/dist/es/utils.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-descriptor.interface.js","../node_modules/@progress/kendo-data-query/dist/es/funcs.js","../node_modules/@progress/kendo-data-query/dist/es/filter-serialization.common.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter.operators.js","../node_modules/@progress/kendo-data-query/dist/es/accessor.js","../node_modules/@progress/kendo-data-query/dist/es/odata.operators.js","../node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js","../node_modules/@progress/kendo-data-query/dist/es/mvc/deserialization.js","../node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js","../node_modules/@progress/kendo-data-query/dist/es/transducers.js","../node_modules/@progress/kendo-data-query/dist/es/grouping/aggregate.operators.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-no-eval.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-expression.factory.js","../node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js","../node_modules/@progress/kendo-data-query/dist/es/sorting/sort.js","../node_modules/@progress/kendo-data-query/dist/es/array.operators.js","../node_modules/@babel/runtime/helpers/inheritsLoose.js","../node_modules/@babel/runtime/helpers/setPrototypeOf.js"],"names":["module","exports","self","ReferenceError","__esModule","obj","key","value","Object","defineProperty","enumerable","configurable","writable","isPresent","undefined","isBlank","isArray","Array","isFunction","isString","isNotNullOrEmptyString","trim","length","isNullOrEmptyString","isNumeric","isNaN","parseFloat","isDate","getTime","isCompositeFilterDescriptor","source","filters","x","ifElse","predicate","right","left","compose","args","_i","arguments","data","reduceRight","acc","curr","toUTC","date","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isDateValue","normalizeOperator","descriptor","map","filter","result","assign","operator","equal","equals","equalto","ge","greater","greaterthan","greaterthanequal","isempty","isequalto","isgreaterthan","isgreaterthanorequalto","islessthan","islessthanorequalto","isnotempty","isnotequalto","isnull","le","less","lessthan","lessthanequal","ne","notequal","notequals","notequalto","notsubstringof","toLowerCase","normalizeFilters","logic","normalizeDescriptor","getterCache","FIELD_REGEX","what","getter","field","safe","fields","replace","_","index","indexAccessor","push","idx","pairwise","empty","has","accessor","isNotEmpty","isNotEmptyArray","runOrEmpty","fn","formatDescriptors","formatter","state","join","sanitizeDateLiterals","apply","_a","s","RegExp","removeAfterDot","str","slice","indexOf","directionFormatter","_b","dir","take","aggregates","skip","group","sort","formatSort","formatGroup","formatAggregates","aggregate","formatDateValue","JSON","stringify","transformSkip","Math","floor","transformTake","transformGroup","transformSort","transformAggregates","filterFormatter","set","ignoreCase","target","prop","fieldName","g1","convert","mapper","values","keys","reduce","bind","translateAggregate","translateAggregates","valueOrDefault","defaultValue","translateGroup","hasSubgroups","items","Aggregates","Member","member","HasSubgroups","Items","Key","compare","a","b","localeCompare","compareDesc","descriptorAsFunc","initial","groupCombinator","position","agg","groupValue","valueToString","__position","aggregatesCombinator","descriptors","functions","fieldAccessor","aggregateName","aggregateAccessor","fieldAggregates","aggregateFunction","average","count","calc","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","sum","concat","arr","transform","isTransformerResult","__value","reduced","exec","initialValue","length_1","identity","aggregateBy","transformers","forEach","expandAggregates","operatorsMap","contains","doesnotcontain","doesnotendwith","doesnotstartwith","lastIndexOf","endswith","eq","gt","gte","isnotnull","lt","lte","neq","startswith","dateRegExp","transformFilter","itemProp","typedGetter","convertValue","op","transformCompositeFilter","combiner","compileFilter","normalizeGroups","groupBy","originalData","view","aggregateResult","filteredData","filterBy","start","end","mid","middle","leftLength","rightLength","temp","cursor1","cursor2","dest","merge","orderBy","some","comparer","composeSortDescriptors","process","skipCount","takeCount","filterDescriptor","sortDescriptors","total","hasFilters","hasGroups","counter","limit","setPrototypeOf","subClass","superClass","prototype","create","constructor","_setPrototypeOf","o","p","__proto__"],"mappings":"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","file":"static/js/2.d17a3306.chunk.js","sourcesContent":["function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","/**\n * @hidden\n */\nexport var isPresent = function (value) { return value !== null && value !== undefined; };\n/**\n * @hidden\n */\nexport var isBlank = function (value) { return value === null || value === undefined; };\n/**\n * @hidden\n */\nexport var isArray = function (value) { return Array.isArray(value); };\n/**\n * @hidden\n */\nexport var isFunction = function (value) { return typeof value === 'function'; };\n/**\n * @hidden\n */\nexport var isString = function (value) { return typeof value === 'string'; };\n/**\n * @hidden\n */\nexport var isTruthy = function (value) { return !!value; };\n/**\n * @hidden\n */\nexport var isNullOrEmptyString = function (value) { return isBlank(value) || value.trim().length === 0; };\n/**\n * @hidden\n */\nexport var isNotNullOrEmptyString = function (value) { return !isNullOrEmptyString(value); };\n/**\n * @hidden\n */\nexport var isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n/**\n * @hidden\n */\nexport var isDate = function (value) { return value && value.getTime; };\n","import { isPresent } from '../utils';\n// tslint:enable:max-line-length\n/**\n * @hidden\n * Type guard for `CompositeFilterDescriptor`.\n */\nexport var isCompositeFilterDescriptor = function (source) {\n    return isPresent(source.filters);\n};\n","/**\n * @hidden\n */\nexport var ifElse = function (predicate, right, left) { return function (value) { return predicate(value) ? right(value) : left(value); }; };\n/**\n * @hidden\n * Performs the right-to-left function composition. Functions should have a unary.\n */\nexport var compose = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return function (data) { return args.reduceRight(function (acc, curr) { return curr(acc); }, data); };\n};\n/**\n * @hidden\n */\nexport var constant = function (x) { return function () { return x; }; };\n/**\n * @hidden\n */\nexport var identity = function (x) { return x; };\n","import * as tslib_1 from \"tslib\";\nimport { isString, isDate } from './utils';\n/**\n * @hidden\n * Creates a single arity function which wraps the value based on the provided predicate.\n * @example\n * ```\n * wrapIf(() => ignoreCase) `tolower(${field})`\n * //ignoreCase=true -> tolower(${field})`\n * //ignoreCase=false -> ${field}`\n * ```\n */\nexport var wrapIf = function (predicate) { return function (str) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return predicate() ? \"\" + str[0] + args[0] + str[1] : args[0];\n}; };\n/**\n * @hidden\n */\nexport var toUTC = function (date) {\n    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n};\n/**\n * @hidden\n */\nexport var quote = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: \"'\" + value.replace(/'/g, \"''\") + \"'\",\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var encodeValue = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: \"\" + encodeURIComponent(value),\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var toLower = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        field: wrapIf(function () { return ignoreCase; })(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"tolower(\", \")\"], [\"tolower(\", \")\"])), field),\n        value: value,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var normalizeField = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: value,\n        field: field.replace(/\\./g, \"/\"),\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var isStringValue = function (x) { return isString(x.value); };\n/**\n * @hidden\n */\nexport var isDateValue = function (x) { return isDate(x.value); };\n/**\n * @hidden\n */\nexport var serializeFilters = function (map, join) { return function (filter) {\n    var brackets = wrapIf(function () { return filter.filters.length > 1; });\n    return brackets(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"(\", \")\"], [\"(\",\n        \")\"])), filter.filters\n        .map(map)\n        .join(join(filter)));\n}; };\nvar templateObject_1, templateObject_2;\n","import { isPresent, isString, isArray } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nvar operatorMap = function (key) { return ({\n    \"!=\": \"neq\",\n    \"<\": \"lt\",\n    \"<=\": \"lte\",\n    \"==\": \"eq\",\n    \">\": \"gt\",\n    \">=\": \"gte\",\n    equal: \"eq\",\n    equals: \"eq\",\n    equalto: \"eq\",\n    ge: \"gte\",\n    greater: \"gt\",\n    greaterthan: \"gt\",\n    greaterthanequal: \"gte\",\n    isempty: \"isempty\",\n    isequalto: \"eq\",\n    isgreaterthan: \"gt\",\n    isgreaterthanorequalto: \"gte\",\n    islessthan: \"lt\",\n    islessthanorequalto: \"lte\",\n    isnotempty: \"isnotempty\",\n    isnotequalto: \"neq\",\n    isnull: \"isnull\",\n    le: \"lte\",\n    less: \"lt\",\n    lessthan: \"lt\",\n    lessthanequal: \"lte\",\n    ne: \"neq\",\n    notequal: \"neq\",\n    notequals: \"neq\",\n    notequalto: \"neq\",\n    notsubstringof: \"doesnotcontain\"\n}[key.toLowerCase()] || key); };\nvar normalizeOperator = function (descriptor) {\n    if (descriptor.filters) {\n        descriptor.filters = descriptor.filters.map(function (filter) {\n            var result = Object.assign({}, filter);\n            if (!isCompositeFilterDescriptor(filter) && isString(filter.operator)) {\n                result.operator = operatorMap(filter.operator);\n            }\n            if (isCompositeFilterDescriptor(filter)) {\n                normalizeOperator(result);\n            }\n            return result;\n        });\n    }\n};\nvar normalizeDescriptor = function (descriptor) {\n    if (!isCompositeFilterDescriptor(descriptor)) {\n        return {\n            filters: isArray(descriptor) ? descriptor : [descriptor],\n            logic: \"and\"\n        };\n    }\n    return Object.assign({}, descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Converts a [FilterDescriptor]({% slug api_kendo-data-query_filterdescriptor %}) into a [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}). If a `CompositeFilterDescriptor` is passed, no modifications will be made.\n *\n * @param {CompositeFilterDescriptor | FilterDescriptor} descriptor - The descriptor that will be normalized.\n * @returns {CompositeFilterDescriptor} - The normalized descriptor.\n */\n// tslint:enable:max-line-length\nexport var normalizeFilters = function (descriptor) {\n    if (isPresent(descriptor)) {\n        descriptor = normalizeDescriptor(descriptor);\n        normalizeOperator(descriptor);\n    }\n    return descriptor;\n};\n","import { isPresent } from './utils';\nvar getterCache = {};\nvar FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\n// tslint:disable-next-line:no-string-literal\ngetterCache['undefined'] = function (obj) { return obj; };\n/**\n * @hidden\n */\nexport var getter = function (field, safe) {\n    var key = field + safe;\n    if (getterCache[key]) {\n        return getterCache[key];\n    }\n    var fields = [];\n    field.replace(FIELD_REGEX, function (_, index, indexAccessor, field) {\n        fields.push(isPresent(index) ? index : (indexAccessor || field));\n        return undefined;\n    });\n    getterCache[key] = function (obj) {\n        var result = obj;\n        for (var idx = 0; idx < fields.length; idx++) {\n            result = result[fields[idx]];\n            if (!isPresent(result) && safe) {\n                return result;\n            }\n        }\n        return result;\n    };\n    return getterCache[key];\n};\n","import * as tslib_1 from \"tslib\";\nimport { isPresent, isNotNullOrEmptyString } from './utils';\nimport { serializeFilter } from './odata-filtering.operators';\nimport { ifElse, constant } from './funcs';\nvar serializeSort = function (orderby) {\n    var str = orderby\n        .filter(function (sort) { return isPresent(sort.dir); })\n        .map(function (sort) {\n        var order = sort.field.replace(/\\./g, \"/\");\n        return sort.dir === \"desc\" ? order + \" desc\" : order;\n    }).join(\",\");\n    return str ? \"$orderby=\" + str : str;\n};\nvar emptyString = constant('');\nvar concat = function (a) { return function (b) { return a + b; }; };\nvar serializeKey = function (strings, val) { return ifElse(isPresent, concat(strings[0]), emptyString)(val); };\nvar rules = function (settings, state) { return function (key) { return ({\n    \"filter\": serializeFilter(state.filter || {}, settings),\n    \"skip\": serializeKey(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"$skip=\", \"\"], [\"$skip=\", \"\"])), state.skip),\n    \"sort\": serializeSort(state.sort || []),\n    \"take\": serializeKey(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"$top=\", \"\"], [\"$top=\", \"\"])), state.take)\n}[key]); }; };\n// tslint:enable:max-line-length\n/**\n * Converts a [State]({% slug api_kendo-data-query_state %}) into an OData v4 compatible string.\n *\n * @param {State} state - The state that will be serialized.\n * @param {ODataSettings} settings - The settings that are used during the serialization.\n * @returns {string} - The serialized state.\n */\nexport var toODataString = function (state, settings) {\n    if (settings === void 0) { settings = {}; }\n    return (Object.keys(state)\n        .map(rules(settings, state))\n        .filter(isNotNullOrEmptyString)\n        .join('&'));\n};\nvar templateObject_1, templateObject_2;\n","import * as tslib_1 from \"tslib\";\nimport { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\nvar toQueryString = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    return acc.concat([key + \"=\" + value]);\n}, []); };\nvar toObject = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    var _b;\n    return (tslib_1.__assign({}, acc, (_b = {}, _b[key] = value, _b)));\n}, {}); };\nvar pairwise = function (key) { return function (value) { return [key, value]; }; };\nvar empty = function () { return null; };\nvar isNotEmptyArray = function (value) { return isPresent(value) && isArray(value) && value.length > 0; };\nvar has = function (accessor) { return function (value) { return isPresent(accessor(value)); }; };\nvar isNotEmpty = function (accessor) { return function (value) { return isNotEmptyArray(accessor(value)); }; };\nvar runOrEmpty = function (predicate, fn) { return ifElse(predicate, fn, empty); };\nvar calcPage = function (_a) {\n    var skip = _a.skip, take = _a.take;\n    return Math.floor((skip || 0) / take) + 1;\n};\nvar formatDescriptors = function (accessor, formatter) { return function (state) { return (accessor(state).map(formatter).join(\"~\")); }; };\nvar removeAfter = function (what) { return function (str) { return str.slice(0, str.indexOf(what)); }; };\nvar replace = function (patterns) {\n    return compose.apply(void 0, patterns.map(function (_a) {\n        var left = _a[0], right = _a[1];\n        return function (s) { return s.replace(new RegExp(left, \"g\"), right); };\n    }));\n};\nvar sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nvar removeAfterDot = removeAfter(\".\");\nvar directionFormatter = function (_a) {\n    var field = _a.field, _b = _a.dir, dir = _b === void 0 ? \"asc\" : _b;\n    return field + \"-\" + dir;\n};\nvar aggregateFormatter = function (_a) {\n    var field = _a.field, aggregate = _a.aggregate;\n    return field + \"-\" + aggregate;\n};\nvar take = getter(\"take\");\nvar aggregates = getter(\"aggregates\");\nvar skip = getter(\"skip\");\nvar group = getter(\"group\");\nvar sort = getter(\"sort\", true);\nvar formatSort = formatDescriptors(sort, directionFormatter);\nvar formatGroup = formatDescriptors(group, directionFormatter);\nvar formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\nvar prefixDateValue = function (value) { return \"datetime'\" + value + \"'\"; };\nvar formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\nvar formatDate = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: formatDateValue(value),\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\nvar normalizeSort = function (state) { return Object.assign({}, state, {\n    sort: (sort(state) || []).filter(function (_a) {\n        var dir = _a.dir;\n        return isNotNullOrEmptyString(dir);\n    })\n}); };\nvar transformSkip = compose(pairwise('page'), calcPage);\nvar transformTake = compose(pairwise('pageSize'), take);\nvar transformGroup = compose(pairwise('group'), formatGroup);\nvar transformSort = compose(pairwise('sort'), formatSort);\nvar transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nvar serializePage = runOrEmpty(has(skip), transformSkip);\nvar serializePageSize = runOrEmpty(has(take), transformTake);\nvar serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nvar serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nvar serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\nvar hasField = function (_a) {\n    var field = _a.field;\n    return isNotNullOrEmptyString(field);\n};\nvar filterFormatter = function (_a) {\n    var field = _a.field, operator = _a.operator, value = _a.value;\n    return field + \"~\" + operator + \"~\" + value;\n};\nvar dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\nvar typedFormatter = function (encode) { return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter)); };\nvar join = function (_a) {\n    var logic = _a.logic;\n    return \"~\" + logic + \"~\";\n};\nvar serialize = function (encode) { return serializeFilters(function (filter) { return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter); }, join); };\nvar serializeFilter = function (_a, encode) {\n    var filter = _a.filter;\n    if (filter && filter.filters) {\n        var filters = serialize(encode)(filter);\n        if (filters.length) {\n            return ['filter', filters];\n        }\n    }\n    return null;\n};\nvar rules = function (state, encode) {\n    if (encode === void 0) { encode = true; }\n    return function (key) { return ({\n        \"aggregates\": serializeAggregates(state),\n        \"filter\": serializeFilter(state, encode),\n        \"group\": serializeGroup(state),\n        \"skip\": serializePage(state),\n        \"sort\": serializeSort(state),\n        \"take\": serializePageSize(state)\n    }[key]); };\n};\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport var toDataSourceRequestString = function (state) { return (toQueryString(Object.keys(state)\n    .map(rules(state))\n    .filter(isPresent)).join('&')); };\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\nexport var toDataSourceRequest = function (state) { return (toObject(Object.keys(state)\n    .map(rules(state, false))\n    .filter(isPresent))); };\n","import { isPresent } from '../utils';\nimport { compose } from '../funcs';\n// tslint:enable:max-line-length\nvar set = function (field, target, value) {\n    target[field] = value;\n    return target;\n};\nvar toCamelCase = function (str) { return str.replace(/(^[A-Z])/g, function (_, g1) { return g1.toLowerCase(); }); };\nvar prop = function (fieldName) { return function (obj) {\n    var value = obj[fieldName];\n    if (isPresent(value)) {\n        return value;\n    }\n    return obj[toCamelCase(fieldName)];\n}; };\nvar member = prop(\"Member\");\nvar aggregateMethodName = prop(\"AggregateMethodName\");\nvar value = prop(\"Value\");\nvar convert = function (mapper) { return function (values) { return Object.keys(values).reduce(mapper.bind(null, values), {}); }; };\nvar translateAggregate = convert(function (source, acc, field) { return set(field.toLowerCase(), acc, source[field]); });\nvar translateAggregates = convert(function (source, acc, field) { return set(field, acc, translateAggregate(source[field])); });\nvar valueOrDefault = function (value, defaultValue) { return isPresent(value) ? value : defaultValue; };\nvar normalizeGroup = function (group) { return ({\n    aggregates: group.Aggregates || group.aggregates,\n    field: group.Member || group.member || group.field,\n    hasSubgroups: group.HasSubgroups || group.hasSubgroups || false,\n    items: group.Items || group.items,\n    value: valueOrDefault(group.Key, valueOrDefault(group.key, group.value))\n}); };\nvar translateGroup = compose(function (_a) {\n    var field = _a.field, hasSubgroups = _a.hasSubgroups, value = _a.value, aggregates = _a.aggregates, items = _a.items;\n    return ({\n        aggregates: translateAggregates(aggregates),\n        field: field,\n        items: hasSubgroups ? items.map(translateGroup) : items,\n        value: value\n    });\n}, normalizeGroup);\n// tslint:disable:max-line-length\n/**\n * Converts the grouped result, which is returned into the `Data` field of the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data - The value of the `Data` field of the response.\n * @returns {GroupResult[]} - The converted result.\n */\nexport var translateDataSourceResultGroups = function (data) { return data.map(translateGroup); };\n/**\n * Converts the `AggregateResults` field content, which is returned by the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data - The value of the `AggregateResults` field of the response.\n * @returns {AggregateResult} - The converted result.\n */\n// tslint:enable:max-line-length\nexport var translateAggregateResults = function (data) { return ((data || []).reduce(function (acc, x) { return set(member(x), acc, set(aggregateMethodName(x).toLowerCase(), acc[member(x)] || {}, value(x))); }, {})); };\n","import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nvar compare = function (a, b) {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nvar compareDesc = function (a, b) { return compare(b, a); };\nvar descriptorAsFunc = function (descriptor) {\n    var prop = getter(descriptor.field, true);\n    return function (a, b) { return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b)); };\n};\nvar initial = function (_a, _b) { return 0; };\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport var composeSortDescriptors = function (descriptors) { return (descriptors\n    .filter(function (x) { return isPresent(x.dir); })\n    .map(function (descriptor) { return descriptorAsFunc(descriptor); })\n    .reduce(function (acc, curr) { return function (a, b) { return acc(a, b) || curr(a, b); }; }, initial)); };\n","import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nvar valueToString = function (value) {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport var groupCombinator = function (field) {\n    var prop = getter(field, true);\n    var position = 0;\n    return function (agg, value) {\n        agg[field] = agg[field] || {};\n        var groupValue = prop(value);\n        var key = valueToString(groupValue);\n        var values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport var expandAggregates = function (result) {\n    if (result === void 0) { result = {}; }\n    Object.keys(result).forEach(function (field) {\n        var aggregates = result[field];\n        Object.keys(aggregates).forEach(function (aggregate) {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nvar aggregatesFuncs = function (name) { return ({\n    average: function () {\n        var value = 0;\n        var count = 0;\n        return {\n            calc: function (curr) {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                }\n                else {\n                    value = curr;\n                }\n            },\n            result: function () { return isNumeric(value) ? value / count : value; }\n        };\n    },\n    count: function () {\n        var state = 0;\n        return {\n            calc: function () { return state++; },\n            result: function () { return state; }\n        };\n    },\n    max: function () {\n        var state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    min: function () {\n        var state = Number.POSITIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    sum: function () {\n        var state = 0;\n        return {\n            calc: function (value) {\n                value = isPresent(value) ? value : 0;\n                state += value;\n            },\n            result: function () { return state; }\n        };\n    }\n}[name]()); };\n/**\n * @hidden\n */\nexport var aggregatesCombinator = function (descriptors) {\n    var functions = descriptors.map(function (descriptor) {\n        var fieldAccessor = getter(descriptor.field, true);\n        var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        var aggregateAccessor = getter(aggregateName, true);\n        return function (state, value) {\n            var fieldAggregates = state[descriptor.field] || {};\n            var aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return function (state, value) { return functions.reduce(function (agg, calc) { return calc(agg, value); }, state); };\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport var concat = function (arr, value) {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport var map = function (transform) { return (function (reduce) { return (function (acc, curr, index) { return reduce(acc, transform(curr, index)); }); }); };\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport var filter = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n */\nexport var isTransformerResult = function (source) {\n    return isPresent(source.__value);\n};\nvar reduced = function (x) {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var take = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- > 0 ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var takeWhile = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport var skip = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- <= 0 ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport var exec = function (transform, initialValue, data) {\n    var result = initialValue;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n","import { exec, map, aggregatesCombinator, expandAggregates } from '../transducers';\nvar identity = map(function (x) { return x; });\n// tslint:disable:max-line-length\n/**\n * Applies the specified [AggregateDescriptors]({% slug api_kendo-data-query_aggregatedescriptor %}) to the data. Returns an [AggregateResult]({% slug api_kendo-data-query_aggregateresult %}) instance.\n *\n * @example\n * ```ts\n * const data = [\n *    { unitPrice: 23, unitsInStock: 21 },\n *    { unitPrice: 10, unitsInStock: 12 },\n *    { unitPrice: 20, unitsInStock: 33 }\n * ];\n *\n * const result = aggregateBy(data, [\n *   { aggregate: \"sum\", field: \"unitPrice\" },\n *   { aggregate: \"sum\", field: \"unitsInStock\" }\n * ]);\n *\n * //output:\n * // {\n * //     \"unitPrice\": { \"sum\": 53 },\n * //     \"unitsInStock\": { \"sum\": 66 }\n * // }\n * ```\n * @param {T[]} data - The data on which the calculation will be executed.\n * @param {AggregateDescriptor[]} descriptors - The aggregate operations that will be executed.\n * @param {any} transformers - For internal use.\n * @returns {AggregateResult} - The aggregated result.\n * For more information, refer to the [aggregateresult]({% slug api_kendo-data-query_aggregateresult %}) configuration.\n */\n// tslint:enable:max-line-length\nexport var aggregateBy = function (data, descriptors, transformers) {\n    if (descriptors === void 0) { descriptors = []; }\n    if (transformers === void 0) { transformers = identity; }\n    var initialValue = {};\n    if (!descriptors.length) {\n        return initialValue;\n    }\n    var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);\n    return expandAggregates(result);\n};\n","import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nvar logic = {\n    \"or\": {\n        concat: function (acc, fn) { return function (a) { return acc(a) || fn(a); }; },\n        identity: function () { return false; }\n    },\n    \"and\": {\n        concat: function (acc, fn) { return function (a) { return acc(a) && fn(a); }; },\n        identity: function () { return true; }\n    }\n};\nvar operatorsMap = {\n    contains: function (a, b) { return (a || \"\").indexOf(b) >= 0; },\n    doesnotcontain: function (a, b) { return (a || \"\").indexOf(b) === -1; },\n    doesnotendwith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0; },\n    doesnotstartwith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === -1; },\n    endswith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0; },\n    eq: function (a, b) { return a === b; },\n    gt: function (a, b) { return a > b; },\n    gte: function (a, b) { return a >= b; },\n    isempty: function (a) { return a === ''; },\n    isnotempty: function (a) { return a !== ''; },\n    isnotnull: function (a) { return isPresent(a); },\n    isnull: function (a) { return isBlank(a); },\n    lt: function (a, b) { return a < b; },\n    lte: function (a, b) { return a <= b; },\n    neq: function (a, b) { return a != b; },\n    startswith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === 0; }\n};\nvar dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nvar convertValue = function (value, ignoreCase) {\n    if (value != null && isString(value)) {\n        var date = dateRegExp.exec(value);\n        if (date) {\n            return new Date(+date[1]).getTime();\n        }\n        else if (ignoreCase) {\n            return value.toLowerCase();\n        }\n    }\n    else if (value != null && isDate(value)) {\n        return value.getTime();\n    }\n    return value;\n};\nvar typedGetter = function (prop, value, ignoreCase) {\n    if (!isPresent(value)) {\n        return prop;\n    }\n    var acc = prop;\n    if (isString(value)) {\n        var date = dateRegExp.exec(value);\n        if (date) {\n            value = new Date(+date[1]);\n        }\n        else {\n            acc = function (a) {\n                var x = prop(a);\n                if (typeof x === 'string' && ignoreCase) {\n                    return x.toLowerCase();\n                }\n                else {\n                    return isNumeric(x) ? x + \"\" : x;\n                }\n            };\n        }\n    }\n    if (isDate(value)) {\n        return function (a) {\n            var x = acc(a);\n            return isDate(x) ? x.getTime() : x;\n        };\n    }\n    return acc;\n};\nvar transformFilter = function (_a) {\n    var field = _a.field, ignoreCase = _a.ignoreCase, value = _a.value, operator = _a.operator;\n    field = !isPresent(field) ? function (a) { return a; } : field;\n    ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n    var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n    value = convertValue(value, ignoreCase);\n    var op = isFunction(operator) ? operator : operatorsMap[operator];\n    return function (a) { return op(itemProp(a), value, ignoreCase); };\n};\n/**\n * @hidden\n */\nexport var transformCompositeFilter = function (filter) {\n    var combiner = logic[filter.logic];\n    return filter.filters\n        .filter(isPresent)\n        .map(function (x) { return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x); })\n        .reduce(combiner.concat, combiner.identity);\n};\n","import { isPresent } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nimport { normalizeFilters } from './filter.operators';\nimport { transformCompositeFilter } from \"./filter-no-eval\";\n// tslint:disable:max-line-length\n/**\n * Creates a [Predicate]({% slug api_kendo-data-query_predicate %}) function for the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {CompositeFilterDescriptor} descriptor - The descriptor for which the predicate is created.\n * @returns {Predicate} - The created function instance.\n *\n * @example\n * ```ts\n * import { compileFilter } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const predicate = compileFilter({ logic: \"and\", filters: [{ field: \"name\", operator: \"startswith\", value: \"P\" }] });\n * const result = data.filter(predicate);\n *\n * ```\n */\n// tslint:enable:max-line-length\nexport var compileFilter = function (descriptor) {\n    if (!descriptor || descriptor.filters.length === 0) {\n        return function () { return true; };\n    }\n    return transformCompositeFilter(descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Filters the provided array according to the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {(CompositeFilterDescriptor | FilterDescriptor)} descriptor - The filter criteria that will be applied.\n * @returns {T[]} - The filtered data.\n *\n * @example\n * ```ts\n * import { filterBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *  { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *  { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *  { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = filterBy(data, {\n *     logic: 'and',\n *     filters: [\n *           { field: \"name\", operator: \"startswith\", value: \"p\", ignoreCase: true },\n *           { field: \"subcategory\", operator: \"eq\", value: \"Meat\" },\n *     ]\n * });\n *\n * // output:\n * // [{ \"name\": \"Pork\", \"category\": \"Food\", \"subcategory\": \"Meat\" }]\n * ```\n */\n// tslint:enable:max-line-length\nexport var filterBy = function (data, descriptor) {\n    if (!isPresent(descriptor) || (isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0)) {\n        return data;\n    }\n    return data.filter(compileFilter(normalizeFilters(descriptor)));\n};\n","import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport var normalizeGroups = function (descriptors) {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(function (x) { return Object.assign({ dir: \"asc\" }, x); });\n};\nvar identity = map(function (x) { return x; });\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport var groupBy = function (data, descriptors, transformers, originalData) {\n    if (descriptors === void 0) { descriptors = []; }\n    if (transformers === void 0) { transformers = identity; }\n    if (originalData === void 0) { originalData = data; }\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    var descriptor = descriptors[0];\n    var initialValue = {};\n    var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    var result = [];\n    Object.keys(view).forEach(function (field) {\n        Object.keys(view[field]).forEach(function (value) {\n            var group = view[field][value];\n            var aggregateResult = {};\n            var filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    return result;\n};\n","var merge = function (data, left, middle, right, compare) {\n    var leftLength = middle - left;\n    var rightLength = right - middle;\n    var temp = [];\n    for (var idx = 0; idx < leftLength; idx++) {\n        temp.push(data[left + idx]);\n    }\n    var cursor1 = 0;\n    var cursor2 = middle;\n    var dest = left;\n    do {\n        if (compare(data[cursor2], temp[cursor1]) < 0) {\n            data[dest++] = data[cursor2++];\n            rightLength--;\n        }\n        else {\n            data[dest++] = temp[cursor1++];\n            leftLength--;\n        }\n    } while (rightLength > 0 && leftLength > 0);\n    while (leftLength) {\n        data[dest++] = temp[cursor1++];\n        leftLength--;\n    }\n    while (rightLength) {\n        data[dest++] = data[cursor2++];\n        rightLength--;\n    }\n};\n/**\n * @hidden\n */\nexport var sort = function (data, start, end, compare) {\n    if (end - start < 2) {\n        return;\n    }\n    var mid = (start + end) >>> 1; // tslint:disable-line:no-bitwise\n    sort(data, start, mid, compare);\n    sort(data, mid, end, compare);\n    merge(data, start, mid, end, compare);\n};\n","import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport var orderBy = function (data, descriptors) {\n    if (descriptors.some(function (x) { return isPresent(x.dir); })) {\n        data = data.slice(0);\n        var comparer = composeSortDescriptors(descriptors);\n        sort(data, 0, data.length, comparer);\n    }\n    return data;\n};\nvar defaultComparer = function (a, b) { return a === b; };\nvar normalizeComparer = function (comparer) {\n    if (isString(comparer)) {\n        var accessor_1 = getter(comparer);\n        comparer = function (a, b) { return accessor_1(a) === accessor_1(b); };\n    }\n    return comparer;\n};\nvar _distinct = function (data, comparer) {\n    return data.filter(function (x, idx, xs) { return xs.findIndex(comparer.bind(null, x)) === idx; });\n};\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport var distinct = function (data, comparer) {\n    if (comparer === void 0) { comparer = defaultComparer; }\n    return _distinct(data, normalizeComparer(comparer));\n};\n/**\n * @hidden\n */\nexport var count = function (data, predicate) {\n    var counter = 0;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport var limit = function (data, predicate) {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport var process = function (data, state) {\n    var skipCount = state.skip, takeCount = state.take, filterDescriptor = state.filter, sort = state.sort, group = state.group;\n    var sortDescriptors = normalizeGroups(group || []).concat(sort || []);\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    var hasFilters = isPresent(filterDescriptor) && filter.length;\n    var hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    var total;\n    var transformers = [];\n    var predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        var transform = compose.apply(void 0, transformers);\n        var result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n","var setPrototypeOf = require(\"./setPrototypeOf.js\");\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inheritsLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"sourceRoot":""}